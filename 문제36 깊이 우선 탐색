/*
문제 설명
깊이 우선 탐색으로 모든 노드를 순회하는 함수 solution을 작성하세요.
시작 노드는 정수형 start로 주어집니다.
graph 배열은 [출발노드, 도착 노드]쌍이 들어있는 배열입니다.
반환값은 그래프의 시작노드부터 모든 노드를 너비 우선 탐색한 경로가 순서대로 저장된 배열입니다.

제약 조건
노드의 최대 개수가 100개를 넘지 않습니다.
시작 노드부터 시작해서 모든 노드를 방문할 수 있는 경로가 항상 있습니다.
그래프의 각 노드는 대문자 알파벳 문자입니다.
*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <vector>
#include <unordered_map>
#include <unordered_set>

using namespace std;

unordered_map<char, vector<char>> adjList;
vector<char> result;
unordered_set<char> visited;

void dfs(char node) {
  //❶ 현재 node를 방문한 목록 및 방문한 경로 추가
  visited.insert(node);    //현재 노드를 방문함에 넣음
  result.push_back(node);  //결과 리스트에 현재 노드 추가

  //❷ 현재 node와 인접한 노드 중, 방문하지 않은 node들에 대해 깊이우선탐색을 계속 진행
  for (char neighbor : adjList[node]) {
    if (visited.find(neighbor) == visited.end()) {
      dfs(neighbor); //반환하지 않으면 재귀호출 
    }
  }
}

vector<char> solution(vector<pair<char, char>> graph, char start) {  // char: 노드 이름, vector char:연결된 이웃 노드 목록
  //❸ 인접 리스트 생성
  for (auto& edge : graph) {
    char u = edge.first;
    char v = edge.second;
    adjList[u].push_back(v);
  }

  //❹ 시작 노드부터 깊이우선탐색 시작
  dfs(start);
  return result;
}
