/*
벨만-포드 알고리즘을 구현한 solution()함수를 구현하세오.
그래프의 각 데이터는 그래프의 정보입니다.
첫 번쨰 데이터는 0번 노드 기준으로 연결된 노드 정보, 두번쨰 데이터는 1번 노드 기준으로 연결된 노드 정보입니다.
노드 정보의 구성은 (노드, 가중치)와 같습니다. 
source는 시작 노드입니다.
최단 거리를 담은 distance 배열을 반환하면 됩니다. 
만약 음의 가중치 순회가 있다면 [-1]을 반환하세요.
음의 가중치 순회란 순회하면 할수록 가중치의 합이 적어지는 순회를 말합니다.

제약 조건
노드의 최대 개수는 100개입니다.
각 간선의 가중치는 -100 이상 100이하입니다.
*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <vector>
#include <limits> //numeric_limits를 사용하기 위함
#include <tuple>  //tuple, tie를 사용하기 위함

using namespace std;

const int INF = numeric_limits<int>::max(); //정수형의 최대값을 무한대로 정의 (실전에서는 가중치를 더하다가 오버플로우 발생 가능성 있음)

vector<int> solution(int num_vertices, vector<tuple<int, int, int>> edges, int source) {
  vector<vector<pair<int, int>>> graph(num_vertices);  //그래프를 인접 리스트로 변

  //❶ 간선정보를 활용해서 인접리스트를 생성
  for (auto& edge : edges) {
    int from, to, weight;
    tie(from, to, weight) = edge;   //tie: 튜플에 묶여 있던 3개의 값을 풀어서 각각 변수에 할당
    graph[from].emplace_back(to, weight);  //from에서 to까지 가고 비용이 weight인 단방향 간선 추
  }

 //❷ 현재까지 구한 최소비용을 INF로 설정(시작노드는 제외)
  vector<int> distance(num_vertices, INF); //모든 노드의 거리를 무한대로 설정
  distance[source] = 0;   //시작 노드에서 자기 자신까지의 거리는 0

  //❸ 정점의 개수 -1 만큼 최소비용을 갱신
  for (int i = 0; i < num_vertices - 1; ++i) {  //v개의 정점을 가지는 그래프의 최단 거리는 최대 v-1개의 간선을 가짐
    for (int u = 0; u < num_vertices; ++u) { //모든 정점 u를 순회
      for (const auto& [v, weight] : graph[u]) { //현재 정점 u와 연결된 모든 간선을 확인

        // 1. distance[u] != INF: u까지 가는 길이 존재해야 함 (방문한 적 있어야 함)
        // 2. distance[u] + weight < distance[v]: u를 거쳐서 v로 가는 게 기존 길보다 빠르면 갱신
        if (distance[u] + weight < distance[v]) { 
          distance[v] = distance[u] + weight;
        }
      }
    }
  }

  //❹ 음의 순환이 있는지 확인
  // V-1번 반복하면 모든 최단 경로가 확정되어야 정상입니다.
  // 그런데 한 번 더 돌렸을 때 값이 또 줄어든다면? -> 무한히 작아지는 '음의 사이클'이 존재한다는 뜻!
  for (int u = 0; u < num_vertices; ++u) {
    for (const auto& [v, weight] : graph[u]) {
        // 여전히 갱신이 일어난다면 문제 발생
      if (distance[u] + weight < distance[v]) {
        return vector<int>(1, -1);  // 음의 순환이 발견되면 {-1} 벡터를 반환하여 에러 표시
      }
    }
  }

  return distance;
}



