/*
소괄호는 짝을 맞춘 괄호 '('와 닫힌 괄호 ')'로 구성합니다.
문제에서는 열린 괄호나 닫힌 괄호가 마구 뒤섞인 문자열 s를 줍니다.
이때 소괄호가 정상적으로 열고 닫혔는지 판별하는 solution() 함수를 구현하세요.
만약 소괄호가 장성적으로 열고 닫혔다면 true를 그렇지 않다면 false를 반환하면 됩니다.

제약조건
열린 괄호는 자신과 가장 가까운 닫힌 괄호를 만나면 상쇄됩니다.
모든 괄호가 상쇄되어 더 이상 아무 괄호도 없어야만 정상으로 열고 닫혔다고 할 수 있습니다.
더 상쇄할 괄호가 없을 때까지 상쇄를 반복합니다.
*/

//===================================================================================================================

int solution(string dirs) {
	int answer = 0;
	int x = 5, y = 5; //시작 좌표를 (5,5)로 설정
	for (auto c : dirs) {
		//반복문을 순회하며 nx, ny는 x, y가 dirs대로 움직였을 떄 위치가 됨
		int dir = todir(c);
		int nx = x + dx[dir];
		int ny = y + dy[dir];
		//좌표 평면을 벗어나면 더이상 이동하지 않음
		if (isNotValid(nx, ny)) {
			continue;
		}
		//다음 좌표를 아직 방문하지 않았을 때
		if (visited[y][x][dir] == false) {
			//방문을 중복 체크하지 않도록 해당 경로의 양방향 방문을 체크
			visited[y][x][dir] = true;
			visited[ny][nx][opposite_direction(dir)] = true;
			answer++;
		}
		//현재 좌표를 이동한 좌표로 업데이트
		x = nx;
		y = ny;
	}

	return answer;
}
