/*
주어진 그래프의 시작 노드를 이용하여 다익스트라 알고리즘을 구현하는 solution()함수를 작성하세요.
시작 노드 start, 노드의 개수 numNodes, [시작 노드, 도착 노드, 가중치]의 형태로 간선 정보를 담은 배열 edges가 인수로 주어집니다.
edges에 [2,1,9]가 있다면 시작 노드 2에서 도착 노드 1까지 가중치 9가 있다는 뜻입니다.
시작 노드  start부터 각 노드까지 최소 비용을 담은 벡터를 반환하는 solution()함수를 구현하세요

제약 조건
그래프의 노드 개수는 최대 10,000개입니다
각 노드는 0이상의 정수로 표현합니다
모든 가중치는 0이상의 정수이며 10,000을 넘지 않습니다
*/
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <vector>
#include <queue>

using namespace std;

// 최대 노드 10,000 * 최대 가중치 10,000 = 100,000,000 
// 오버플로우를 막으면서 충분히 큰 값을 무한대로 설정합니다.
const int INF = 1e9; 

vector<int> solution(int start, int numNodes, vector<vector<int>> edges) {
    
    // ❶ 인접 리스트 생성: 메모리를 아끼기 위해 연결된 길만 저장합니다.
    // adjList[i]에는 i번 노드와 연결된 {도착 노드, 가중치} 들이 들어갑니다.
    vector<vector<pair<int, int>>> adjList(numNodes);
    for (const auto& edge : edges) {
        int from = edge[0];
        int to = edge[1];
        int weight = edge[2];
        adjList[from].push_back({to, weight});
    }

    // ❷ 최단 거리 테이블 초기화
    vector<int> distances(numNodes, INF);
    distances[start] = 0;

    // ❸ 우선순위 큐 생성 (다익스트라의 핵심 엔진)
    // 큐 안에는 {현재까지의 최단 거리, 노드 번호} 형태로 들어갑니다.
    // C++의 우선순위 큐는 기본이 '최대 힙(큰 값이 먼저 나옴)'이므로, 
    // 거리가 '짧은(작은)' 것부터 나오게 하려면 greater를 반드시 써줘야 합니다.
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    
    // 출발점 세팅 (거리 0, 시작 노드)
    pq.push({0, start});

    // ❹ 탐색 시작
    while (!pq.empty()) {
        // 우선순위 큐가 알아서 '가장 거리가 짧은 노드'를 맨 앞으로 가져와 줍니다. (탐욕적 선택)
        int current_dist = pq.top().first;  // 현재 노드까지의 비용
        int current_node = pq.top().second; // 현재 노드 번호
        pq.pop(); // 꺼냈으니 대기열에서 제거

        // [최적화 방어 코드]
        // 큐에서 꺼낸 거리가 이미 기록된 최단 거리보다 멀다면? 
        // -> 예전에 큐에 들어갔던 쓸모없는(더 느린) 정보이므로 가볍게 무시합니다.
        if (distances[current_node] < current_dist) {
            continue;
        }

        // ❺ 인접 노드 탐색 및 거리 갱신 (완화, Relaxation)
        for (const auto& neighbor : adjList[current_node]) {
            int next_node = neighbor.first; // 연결된 이웃 노드
            int weight = neighbor.second;   // 거기로 가는 가중치

            // 새로운 경로의 비용 = (현재 노드까지 온 비용) + (이웃으로 가는 비용)
            int new_dist = current_dist + weight;

            // 새로 계산한 비용이 기존에 알고 있던 이웃의 최단 거리보다 저렴하다면?
            if (new_dist < distances[next_node]) {
                distances[next_node] = new_dist; // 최단 거리를 갱신하고
                pq.push({new_dist, next_node});  // "이 경로가 더 빠르니 다시 주변을 탐색해봐!" 하고 큐에 넣음
            }
        }
    }

    return distances;
}







