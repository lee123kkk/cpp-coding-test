/*
문제 설명
상호배타적 집합을 표현하고 관리하는데 다음 두 연산이 필요합니다.
union(x,y):x와 y가 속한 두 집합을 합칩니다.
find(x); x가 속한 집합의 대표 원소를 찾습니다.

operations라는 배열은 수행할 연산을 의미합니다.
연산 종류는 2가지입니다.

['u', 1, 2]는 노드1과 노드2에 대해 union 연산 수행
['f', 1, 2]는 노드1과 노드2의 루트 노드가 같은지 find연산으로 확인해서 같으면 true, 다르면 false를 반환
경로 압축과 랭크 기반 합치기를 활용해서 유니온-파인드 알고리즘을 구현해주세요.
poerations배열에 있는 연산을 모두 수행한 뒤 find 연산 결과를 순서에 맞춰 벡터에 담아 반환하는 solution함수를 구현하세요.

제약 조건
-1<k<1001 노드의 개수
0<len(operation)<100001
operations[i][0]은 문자열 'u' 또는 'f'중 하나
'u'는 union 연산, union연산 뒤로는 두개의 정수 x, y가 나옴
'f'는 find 연산, find연산 뒤에는 두 개의 정수 x, y가 나옴
x와 y는 0이상 k-1이하의 정수
*/
////////////////////////////////////////////////////////////////////////////////////

#include <vector>

using namespace std;

vector<int> parents; 
vector<int> rankData;

// 문자를 숫자로 변환
int charToInt(char c) {
  return c - '0';
}

int find(int x) {
  // x의 부모가 자신인 경우 루트노드를 찾았으므로 반환    
  if (parents[x] == x) {
    return x; 
  }
  
  // 파인드 연산 시, 경로압축 사용
  parents[x] = find(parents[x]);
  
  return parents[x];
}

void unionSet(int x, int y) {
  int root1 = find(x);
  int root2 = find(y);

  // 루트 노드가 같을 경우 유니온 연산을 할 필요가 없음
  if (root1 != root2) {
    // 랭크기반 알고리즘으로 유니온 연산 수행  
    if (rankData[root1] < rankData[root2]) {
      parents[root1] = root2;
    } 
    else if (rankData[root1] > rankData[root2]) {
      parents[root2] = root1;
    } 
    else {
      parents[root2] = root1;
      rankData[root1]++;
    }
  }
}

vector<bool> solution(int k, vector<vector<char>> operations) {
  parents.resize(k);
  rankData.resize(k, 0);
  
  // 초기에 각 노드는 자신을 부모로 설정
  for (int i = 0; i < k; ++i) {
    parents[i] = i;
  }

  vector<bool> results;
  for (const auto& op : operations) {
    if (op[0] == 'u') {
      int x = charToInt(op[1]);
      int y = charToInt(op[2]);
      unionSet(x, y);
    } 
    else if (op[0] == 'f') {
      int x = charToInt(op[1]);
      int y = charToInt(op[2]);
      // 파인드 연산을 통화 x,y의 루트노드가 같은지 확인해서 결과 저장
      results.push_back(find(x) == find(y));
    }
  }

  return results;
}
