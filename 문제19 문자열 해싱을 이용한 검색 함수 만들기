/*
문자열 배열 string_list와 쿼리 배열  query_list가 있을 때 각 쿼리 배열에 있는 문자열이 string_list의 문자열 배열에 있는지 여부를 확인해야 합니다.
문자열에 있으면 true, 없으면 false가 됩니다.
각 문자역에 대해서 문자열의 존재 여부를 배열 형태로 반환하는 solution() 함수를 작성해주세요.

제약 조건
입력 문자열은 영어 소문자로만 이루어져 있습니다.
문자열의 최대 길이는 1,000,000입니다.
해시 충돌은 고려하지 않습니다.
아래와 같은 문자열 해싱 방법을 활용해서 구현하세요.
다음 식에서 p는 31, m은 1.000,000,007로 합니다.
- hash(s) = (s[0] + s[1]*p + s[2}*p*p ........ s[n-1]*p(n-1승))mod m

string_list                       query_list                               result
["apple", "banna", "cherry"]      ["banana", "kiwi", "melon", "apple"]     [true, false true, false]
*/

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



#include <vector>
#include <string>
#include <unordered_set>

using namespace std;

// ❶ 다항 해시 함수 구현
long long polynomial_hash(const string& str) {    //str: 알파벳을 숫자로 바꿀 때 사용할 가중치
    const int p = 31;  // 소수
    const long long m = 1000000007;  // 버킷 크기 (나눌 수)
    long long hash_value = 0;
    
    for (char c : str) {             //str의 글자를 순서대로 c에 넣으면 반복
        hash_value = (hash_value * p + c) % m;  //이전 값에 31을 더하고 아스키 코드값을 구한 뒤 m으로 나눔
    }
    
    return hash_value;
}

vector<bool> solution(vector<string> string_list, vector<string> query_list) {
    unordered_set<long long> hash_set;
    
    //❷ string_list의 각 문자열에 대해 다항 해시값을 계산하고 저장
    for (const string& str : string_list) {  //단어들을 숫자로 바꿔서 저장
        long long hash = polynomial_hash(str);  //저장소 만들기
        hash_set.insert(hash);             //저장소에 넣기
    }
    
    vector<bool> result;
    
    //❸  query_list의 각 문자열이 string_list에 있는지 확인하고 result에 추가
    for (const string& query : query_list) {
        long long query_hash = polynomial_hash(query);              //찾을 단어를 지뭉으로 삼음
        bool found = (hash_set.find(query_hash) != hash_set.end()); //지문 찾기
        result.push_back(found);
    }
    // ❹ query_list의 문자열이 hash에 있는지 결과가 저장된 result를 반환
    return result;
}
